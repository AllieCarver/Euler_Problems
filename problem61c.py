#!-*-coding=utf8 -*-

import time

"""
========================
Project Euler Problem 61
========================


Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:
Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

  1)  The set is cyclic, in that the last two digits of each number is the first
     two digits of the next number (including the last number with the first).

  2)  Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
     pentagonal (P5,44=2882), is represented by a different number in the set.

  3) This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.



"""

def tri(n):
    return n * (n + 1)/2

def squ(n):
    return n**2

def pen(n):
    return n * (3*n - 1)/2

def hexa(n):
    return n*(2*n - 1)

def hep(n):
    return n*(5*n-3)/2

def octa(n):
    return n*(3*n-2)
    
def problem61():
    tri_set = set([])
    squ_set = set([])
    pen_set = set([])
    hexa_set = set([])
    hep_set = set([])
    octa_set = set([])

    poly_dic = {'left': set([]), 'right': set([])}
    squ_dic = {'left': set([]), 'right': set([])}
    pen_dic = {'left': set([]), 'right': set([])}
    hexa_dic = {'left': set([]), 'right': set([])}
    hep_dic = {'left': set([]), 'right': set([])}
    octa_dic = {'left': set([]), 'right': set([])}

    tri_ = True
    squ_ = True
    pen_ = True
    hexa_ = True
    hep_ = True
    octa_ = True

    n = 0

    while tri_ or squ_ or pen_ or hexa_ or hep_ or octa_:
          if tri_:
                num = tri(n)
                if 999 < num < 10000:
                      tri_set.add(str(num))
                      poly_dic['left'].add(str(num)[:2])
                      poly_dic['right'].add(str(num)[2:])
                elif num > 10000:
                      tri_ = False

          if squ_:
                num = squ(n)
                if 999 < num < 10000:
                      squ_set.add(str(num))
                      poly_dic['left'].add(str(num)[:2])
                      poly_dic['right'].add(str(num)[2:])
                elif num > 10000:
                      squ_ = False
          if pen_:
                num = pen(n)
                if 999 < num < 10000:
                    pen_set.add(str(num))
                    poly_dic['left'].add(str(num)[:2])
                    poly_dic['right'].add(str(num)[2:])
                elif num > 10000:
                      pen_ = False
          if hexa_:
                num = hexa(n)
                if 999 < num < 10000:
                      hexa_set.add(str(num))
                      poly_dic['left'].add(str(num)[:2])
                      poly_dic['right'].add(str(num)[2:])
                elif num > 10000:
                      hexa_ = False

          if hep_:
                num = hep(n)
                if 999 < num < 10000:
                      hep_set.add(str(num))
                      poly_dic['left'].add(str(num)[:2])
                      poly_dic['right'].add(str(num)[2:])
                elif num > 10000:
                      hep_ = False

          if octa_:
                num = octa(n)
                if 999 < num < 10000:
                      octa_set.add(str(num))
                      poly_dic['left'].add(str(num)[:2])
                      poly_dic['right'].add(str(num)[2:])
                elif num > 10000:
                      octa_ = False 
          n += 1

    b= 0
    while b < 4:
        octa2 = set([])
        new_poly_dic = {'left': set([]), 'right': set([])}
        for i in octa_set:
            if i[:2] in poly_dic['right']:
                if i[2:] in poly_dic['left']:
                    octa2.add(i)
                    new_poly_dic['left'].add(i[:2])
                    new_poly_dic['right'].add(i[2:])                    
        octa_set = octa2
        

        hep2 = set([])
        
        for j in hep_set:
            if j[2:] in poly_dic['left']:
                if j[:2] in poly_dic['right']:
                    hep2.add(j)
                    new_poly_dic['left'].add(j[:2])
                    new_poly_dic['right'].add(j[2:])
                    changed = True
        hep_set = hep2
 
        hexa2 = set([])
        for k in hexa_set:
            if k[2:] in poly_dic['left']:
                if k[:2] in poly_dic['right']:
                    hexa2.add(k)
                    new_poly_dic['left'].add(k[:2])
                    new_poly_dic['right'].add(k[2:])
        hexa_set = hexa2

        pen2 = set([])
        for l in pen_set:
            if l[2:] in poly_dic['left']:
                if l[:2] in poly_dic['right']:
                    pen2.add(l)
                    new_poly_dic['left'].add(l[:2])
                    new_poly_dic['right'].add(l[2:])
        pen_set = pen2

        squ2 = set([])
        for m in squ_set:
            if m[2:] in poly_dic['left']:
                if m[:2] in poly_dic['right']:
                    squ2.add(m)
                    new_poly_dic['left'].add(m[:2])
                    new_poly_dic['right'].add(m[2:])
        squ_set = squ2

        tri2 = set([])
        tri_dic = {'left': set([]), 'right': set([])}
        for n in tri_set:
            if n[2:] in poly_dic['left']:
                if n[:2] in poly_dic['right']:
                    tri2.add(n)
                    new_poly_dic['left'].add(n[:2])
                    new_poly_dic['right'].add(n[2:])
        poly_dic =  new_poly_dic
        b+=1
    polys = tri_set
    polys.update(squ_set)
    polys.update(pen_set)
    polys.update(hexa_set)
    polys.update(hep_set)
    polys.update(octa_set)
    cyclical = set([])
    for a in polys:
        for b in set([i for i  in polys if i[:2] == a[2:]]):
            for c in set([i for i in polys if i[:2] == b[2:]]):
                for d in set([i for i in polys if i[:2] == c[2:]]):
                    for e in set([i for i in polys if i[:2] == d[2:]]):
                        for f in set([i for i in polys if i[:2] == e[2:]]):
                            if f[2:] == a[:2]:
                                x= set([a,b,c,d,e,f])
                                if len(x)==6:
                                    cyclical.add((a,b,c,d,e,f))

    for perm in cyclical:
        types = set([])
        for num in perm:
            if num in octa_set:
                types.add('octa')
            elif num in hep_set:
                types.add('hep')
            elif num in hexa_set:
                types.add('hexa')
            elif num in pen_set:
                types.add('pen')
            elif num in squ_set:
                types.add('squ')
            elif num in tri_set:
                types.add('tri')
           
        if len(types)==6:
            return perm, sum([int(i) for i in perm])
                                      
if __name__ == '__main__':        
    time1=time.time()
    print problem61()
    time2=time.time()
    print time2-time1
